use crate::{theme::Theme, util::get_subtheme};
use std::fs;

#[derive(Debug, Clone)]
pub struct Component {
    name: String,
    comment: String,
    pos: (u32, u32),
    enabled: bool,
}

#[derive(Debug)]
pub struct Variable {
    name: String,
    comment: String,
    value: String,
    var_type: VarType,
    pos: (u32, u32),
}

#[derive(Debug)]
pub enum VarType {
    Slider,
    Text,
    Color,
}

#[derive(Debug, Clone)]
pub struct Config {
    pub raw: String,
    pub hyprpaper_raw: String,
    pub theme: Theme,
}

impl Config {
    pub fn from_theme(mut theme: Theme) -> Config {
        match get_subtheme(&theme) {
            Some(subtheme) => theme = subtheme,
            None => {}
        }

        Config {
            raw: {
                format!(
                    "#====== generated by hyprtheme ======#\n$THEME_DIR={}\n\n{}",
                    theme.conf.parent().unwrap().to_str().unwrap(),
                    fs::read_to_string(&theme.conf)
                        .expect("Unable to read from theme config file")
                        .as_str()
                )
            },
            hyprpaper_raw: {
                if theme.hyprpaper.exists() {
                    format!(
                        "#====== generated by hyprtheme ======#\n$THEME_DIR={}\n\n{}",
                        theme.conf.parent().unwrap().to_str().unwrap(),
                        fs::read_to_string(&theme.hyprpaper)
                            .expect("Unable to read from theme config file")
                            .as_str().replace("$THEME_DIR", "$__THEME_DIR")
                    )
                } else {
                    String::new()
                }
            },
            theme,
        }
    }
    pub fn build_conf(&self) -> String {
        self.raw.to_owned()
    }
    pub fn build_hyprpaper(&self) -> String {
        self.hyprpaper_raw.to_owned()
    }
}
